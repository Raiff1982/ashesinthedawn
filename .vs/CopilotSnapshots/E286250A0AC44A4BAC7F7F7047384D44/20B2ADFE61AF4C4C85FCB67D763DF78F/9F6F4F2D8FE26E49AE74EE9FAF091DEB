/**
 * AUTOMATION CURVE EDITOR
 * Cubic Bézier curve editor for volume, pan, and parameter automation
 */

import { useState, useRef, useEffect } from 'react';
import { X } from 'lucide-react';

interface CurvePoint {
  x: number; // 0-1
  y: number; // 0-1
  tension?: number; // 0-1 for curve smoothness
}

interface AutomationCurveEditorProps {
  trackId: string;
  points: CurvePoint[];
  onPointsChange: (points: CurvePoint[]) => void;
  curveType?: 'volume' | 'pan' | 'custom';
  height?: number;
  width?: number;
}

export function AutomationCurveEditor({
  trackId: _trackId,
  points = [
    { x: 0, y: 0.5, tension: 0 },
    { x: 1, y: 0.5, tension: 0 },
  ],
  onPointsChange,
  curveType: _curveType = 'volume',
  height = 200,
  width = 400,
}: AutomationCurveEditorProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [selectedPointIndex, setSelectedPointIndex] = useState<number | null>(null);
  const [isDragging, setIsDragging] = useState(false);

  // Pre-defined curve shapes
  const curvePresets = {
    linear: [
      { x: 0, y: 0.2, tension: 0 },
      { x: 1, y: 0.8, tension: 0 },
    ],
    exponential: [
      { x: 0, y: 0.1, tension: 0.3 },
      { x: 0.5, y: 0.3, tension: 0.4 },
      { x: 1, y: 0.9, tension: 0.3 },
    ],
    swell: [
      { x: 0, y: 0.3, tension: 0 },
      { x: 0.5, y: 0.9, tension: 0.5 },
      { x: 1, y: 0.3, tension: 0 },
    ],
    constant: [
      { x: 0, y: 0.5, tension: 0 },
      { x: 1, y: 0.5, tension: 0 },
    ],
  };

  // Draw curve on canvas
  useEffect(() => {
    if (!canvasRef.current) return;

    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const w = canvas.width;
    const h = canvas.height;
    const padding = 40;
    const graphWidth = w - padding * 2;
    const graphHeight = h - padding * 2;

    // Clear canvas
    ctx.fillStyle = '#111827';
    ctx.fillRect(0, 0, w, h);

    // Draw grid
    ctx.strokeStyle = '#374151';
    ctx.lineWidth = 0.5;
    for (let i = 0; i <= 4; i++) {
      const x = padding + (i / 4) * graphWidth;
      const y = padding + (i / 4) * graphHeight;
      ctx.beginPath();
      ctx.moveTo(x, padding);
      ctx.lineTo(x, h - padding);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(padding, y);
      ctx.lineTo(w - padding, y);
      ctx.stroke();
    }

    // Draw axes
    ctx.strokeStyle = '#4b5563';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(padding, h - padding);
    ctx.lineTo(w - padding, h - padding);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(padding, padding);
    ctx.lineTo(padding, h - padding);
    ctx.stroke();

    // Draw curve with Catmull-Rom interpolation
    ctx.strokeStyle = '#3b82f6';
    ctx.lineWidth = 2;
    ctx.beginPath();

    const sortedPoints = [...points].sort((a, b) => a.x - b.x);

    for (let i = 0; i < sortedPoints.length - 1; i++) {
      const p0 = i === 0 ? sortedPoints[0] : sortedPoints[i - 1];
      const p1 = sortedPoints[i];
      const p2 = sortedPoints[i + 1];
      const p3 = i === sortedPoints.length - 2 ? p2 : sortedPoints[i + 2];

      const tension = (p1.tension || 0.5) * 0.5;

      for (let t = 0; t <= 1; t += 0.02) {
        const t2 = t * t;
        const t3 = t2 * t;

        const mt = 1 - t;
        const mt2 = mt * mt;
        const mt3 = mt2 * mt;

        const q =
          mt3 * p1.x +
          3 * mt2 * t * (p1.x + tension * (p2.x - p0.x)) +
          3 * mt * t2 * (p2.x - tension * (p3.x - p1.x)) +
          t3 * p2.x;

        const r =
          mt3 * p1.y +
          3 * mt2 * t * (p1.y + tension * (p2.y - p0.y)) +
          3 * mt * t2 * (p2.y - tension * (p3.y - p1.y)) +
          t3 * p2.y;

        const px = padding + q * graphWidth;
        const py = h - padding - r * graphHeight;

        if (i === 0 && t === 0) {
          ctx.moveTo(px, py);
        } else {
          ctx.lineTo(px, py);
        }
      }
    }
    ctx.stroke();

    // Draw points
    sortedPoints.forEach((point, idx) => {
      const px = padding + point.x * graphWidth;
      const py = h - padding - point.y * graphHeight;

      if (idx === selectedPointIndex) {
        ctx.fillStyle = '#fbbf24';
        ctx.beginPath();
        ctx.arc(px, py, 6, 0, Math.PI * 2);
        ctx.fill();
      } else {
        ctx.fillStyle = '#3b82f6';
        ctx.beginPath();
        ctx.arc(px, py, 4, 0, Math.PI * 2);
        ctx.fill();
      }
    });
  }, [points, selectedPointIndex]);

  // Handle canvas interactions
  const handleCanvasMouseDown = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!canvasRef.current) return;

    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const w = canvas.width;
    const h = canvas.height;
    const padding = 40;
    const graphWidth = w - padding * 2;
    const graphHeight = h - padding * 2;

    // Check if clicking on a point
    points.forEach((point, idx) => {
      const px = padding + point.x * graphWidth;
      const py = h - padding - point.y * graphHeight;
      const distance = Math.sqrt((x - px) ** 2 + (y - py) ** 2);

      if (distance < 8) {
        setSelectedPointIndex(idx);
        setIsDragging(true);
      }
    });

    // If not on a point, add new point
    if (selectedPointIndex === null) {
      const nx = Math.max(0, Math.min(1, (x - padding) / graphWidth));
      const ny = Math.max(0, Math.min(1, 1 - (y - padding) / graphHeight));

      const newPoint: CurvePoint = { x: nx, y: ny, tension: 0.5 };
      const newPoints = [...points, newPoint];
      onPointsChange(newPoints);
      setSelectedPointIndex(newPoints.length - 1);
      setIsDragging(true);
    }
  };

  const handleMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!isDragging || selectedPointIndex === null || !canvasRef.current) return;

    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const w = canvas.width;
    const h = canvas.height;
    const padding = 40;
    const graphWidth = w - padding * 2;
    const graphHeight = h - padding * 2;

    const nx = Math.max(0, Math.min(1, (x - padding) / graphWidth));
    const ny = Math.max(0, Math.min(1, 1 - (y - padding) / graphHeight));

    const newPoints = [...points];
    newPoints[selectedPointIndex] = { ...newPoints[selectedPointIndex], x: nx, y: ny };
    onPointsChange(newPoints);
  };

  const handleMouseUp = () => {
    setIsDragging(false);
  };

  // Delete point
  const deletePoint = (index: number) => {
    if (points.length <= 2) return;
    const newPoints = points.filter((_, i) => i !== index);
    onPointsChange(newPoints);
    setSelectedPointIndex(null);
  };

  // Apply preset
  const applyPreset = (preset: CurvePoint[]) => {
    onPointsChange(preset);
    setSelectedPointIndex(null);
  };

  return (
    <div className="space-y-3 p-3 bg-gray-800 rounded-lg border border-gray-700">
      <div className="flex items-center justify-between">
        <label className="text-xs font-semibold text-gray-400">AUTOMATION CURVE</label>
        <div className="flex gap-1">
          {Object.entries(curvePresets).map(([name, preset]) => (
            <button
              key={name}
              onClick={() => applyPreset(preset)}
              className="px-2 py-1 text-xs bg-gray-700 hover:bg-gray-600 text-gray-300 rounded transition capitalize"
            >
              {name}
            </button>
          ))}
        </div>
      </div>

      <div
        className="space-y-2"
        title="Automation Curve
Draw an automation curve for this parameter. Click to add points, drag to move, right-click to delete.
Category: mixer
Related Functions: Volume Envelope, LFO, MIDI Automation
Performance Tip: Use fewer points for smoother curves and better performance

Examples:
Fade in/out: Linear curve from low to high
Swell: Exponential curve for dynamic swells
Ducking: Inverse curve for automated ducking"
      >
        <div className="space-y-2">
          <canvas
            ref={canvasRef}
            width={width}
            height={height}
            onMouseDown={handleCanvasMouseDown}
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onMouseLeave={handleMouseUp}
            className="w-full border border-gray-700 rounded cursor-crosshair bg-gray-900"
            style={{ display: 'block' }}
          />

          {/* Point list */}
          <div className="space-y-1">
            {points.map((point, idx) => (
              <div
                key={idx}
                onClick={() => setSelectedPointIndex(idx)}
                className={`flex items-center justify-between px-2 py-1 rounded text-xs cursor-pointer transition ${
                  idx === selectedPointIndex
                    ? 'bg-blue-600 text-white'
                    : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                }`}
              >
                <span>
                  Point {idx + 1}: ({point.x.toFixed(2)}, {point.y.toFixed(2)})
                </span>
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    deletePoint(idx);
                  }}
                  disabled={points.length <= 2}
                  className="p-0.5 hover:bg-red-600 disabled:opacity-50 rounded"
                >
                  <X className="w-3 h-3" />
                </button>
              </div>
            ))}
          </div>
        </div>
      </div>
    </div>
  );
}
