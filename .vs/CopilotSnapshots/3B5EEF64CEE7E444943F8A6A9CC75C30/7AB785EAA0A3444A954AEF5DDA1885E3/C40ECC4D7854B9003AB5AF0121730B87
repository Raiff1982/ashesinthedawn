import React, {
  createContext,
  useContext,
  useState,
  useEffect,
  useRef,
  useMemo,
} from "react";
import type {
  Track,
  Project,
  LogicCoreMode,
  Plugin,
  Marker,
  LoopRegion,
  MetronomeSettings,
  Bus,
  MidiDevice,
  MidiRoute,
  AudioContextState,
} from "@/types";
import { getAudioEngine } from "../lib/audioEngine";
import { getCodetteBridge, CodetteSuggestion } from "../lib/codetteBridge";
import { setDAWContext } from "../lib/actions/initializeActions";
import { supabase } from "../lib/supabase";
import {
  saveProjectToStorage,
  loadProjectFromStorage,
  clearProjectStorage,
  createAutoSaveInterval,
} from "../lib/projectStorage";
import {
  downloadProjectFile,
  importProjectFromFile,
  openFileDialog,
} from "../lib/projectImportExport";
import { useEffectChainAPI, EffectChainContextAPI } from "../lib/effectChainContextAdapter";

interface DAWContextType {
  currentProject: Project | null;
  tracks: Track[];
  selectedTrack: Track | null;
  isPlaying: boolean;
  isRecording: boolean;
  currentTime: number;
  zoom: number;
  logicCoreMode: LogicCoreMode;
  voiceControlActive: boolean;
  cpuUsage: number;
  isUploadingFile: boolean;
  uploadError: string | null;
  deletedTracks: Track[]; // Trash
  canUndo: boolean;
  canRedo: boolean;
  markers: Marker[];
  loopRegion: LoopRegion;
  metronomeSettings: MetronomeSettings;
  inputLevel: number;
  latencyMs: number;
  bufferUnderruns: number;
  bufferOverruns: number;
  isAudioIOActive: boolean;
  audioIOError: string | null;
  selectedInputDevice: { label: string } | null;
  selectedInputDeviceId: string | null;
  selectedOutputDeviceId: string | null;
  selectInputDevice: (deviceId: string) => Promise<void>;
  selectOutputDevice: (deviceId: string) => Promise<void>;
  getAudioContextStatus: () => AudioContextState | string;
  setCurrentProject: (project: Project | null) => void;
  addTrack: (type: Track["type"]) => void;
  selectTrack: (trackId: string) => void;
  updateTrack: (trackId: string, updates: Partial<Track>) => void;
  deleteTrack: (trackId: string) => void; // Soft delete to trash
  duplicateTrack: (trackId: string) => Promise<Track | null>;
  restoreTrack: (trackId: string) => void; // Restore from trash
  permanentlyDeleteTrack: (trackId: string) => void; // Hard delete
  togglePlay: () => void;
  toggleRecord: () => void;
  stop: () => void;
  setLogicCoreMode: (mode: LogicCoreMode) => void;
  toggleVoiceControl: () => void;
  saveProject: () => Promise<void>;
  loadProject: (projectId: string) => Promise<void>;
  uploadAudioFile: (file: File) => Promise<boolean>;
  getWaveformData: (trackId: string) => number[];
  getAudioDuration: (trackId: string) => number;
  getAudioBufferData: (trackId: string) => Float32Array | null;
  getAudioLevels: () => Uint8Array | null;
  seek: (timeSeconds: number) => void;
  setTrackInputGain: (trackId: string, gainDb: number) => void;
  addPluginToTrack: (trackId: string, plugin: Plugin) => void;
  removePluginFromTrack: (trackId: string, pluginId: string) => void;
  togglePluginEnabled: (
    trackId: string,
    pluginId: string,
    enabled: boolean
  ) => void;
  undo: () => void;
  redo: () => void;
  // Phase 3: Markers
  addMarker: (time: number, name: string) => void;
  deleteMarker: (markerId: string) => void;
  updateMarker: (markerId: string, updates: Partial<Marker>) => void;
  // Phase 3: Looping
  setLoopRegion: (startTime: number, endTime: number) => void;
  toggleLoop: () => void;
  clearLoopRegion: () => void;
  // Phase 3: Metronome
  toggleMetronome: () => void;
  setMetronomeVolume: (volume: number) => void;
  setMetronomeBeatSound: (sound: MetronomeSettings["beatSound"]) => void;
  // Modal State
  showNewProjectModal: boolean;
  openNewProjectModal: () => void;
  closeNewProjectModal: () => void;
  showExportModal: boolean;
  openExportModal: () => void;
  closeExportModal: () => void;
  showAudioSettingsModal: boolean;
  openAudioSettingsModal: () => void;
  closeAudioSettingsModal: () => void;
  showAboutModal: boolean;
  openAboutModal: () => void;
  closeAboutModal: () => void;
  // Additional Modals
  showSaveAsModal: boolean;
  openSaveAsModal: () => void;
  closeSaveAsModal: () => void;
  showOpenProjectModal: boolean;
  openOpenProjectModal: () => void;
  closeOpenProjectModal: () => void;
  showMidiSettingsModal: boolean;
  openMidiSettingsModal: () => void;
  closeMidiSettingsModal: () => void;
  showMixerOptionsModal: boolean;
  openMixerOptionsModal: () => void;
  closeMixerOptionsModal: () => void;
  showPreferencesModal: boolean;
  openPreferencesModal: () => void;
  closePreferencesModal: () => void;
  showShortcutsModal: boolean;
  openShortcutsModal: () => void;
  closeShortcutsModal: () => void;
  // Export
  exportAudio: (format: string, quality: string) => Promise<void>;
  // Project Import/Export
  exportProjectAsFile: () => void;
  importProjectFromFile: () => Promise<void>;
  // Bus/Routing functions
  buses: Bus[];
  createBus: (name: string) => void;
  deleteBus: (busId: string) => void;
  addTrackToBus: (trackId: string, busId: string) => void;
  removeTrackFromBus: (trackId: string, busId: string) => void;
  createSidechain: (sourceTrackId: string, targetTrackId: string) => void;
  // Plugin functions
  loadPlugin: (trackId: string, pluginName: string) => void;
  unloadPlugin: (trackId: string, pluginId: string) => void;
  loadedPlugins: Map<string, Plugin[]>;
  // MIDI functions
  midiDevices: MidiDevice[];
  createMIDIRoute: (sourceDeviceId: string, targetTrackId: string) => void;
  deleteMIDIRoute: (routeId: string) => void;
  getMIDIRoutesForTrack: (trackId: string) => MidiRoute[];
  // Codette AI Integration (Phase 1)
  codetteConnected: boolean;
  codetteLoading: boolean;
  codetteSuggestions: CodetteSuggestion[];
  getSuggestionsForTrack: (
    trackId: string,
    context?: string
  ) => Promise<CodetteSuggestion[]>;
  applyCodetteSuggestion: (
    trackId: string,
    suggestion: CodetteSuggestion
  ) => Promise<boolean>;
  analyzeTrackWithCodette: (trackId: string) => Promise<any>;
  syncDAWStateToCodette: () => Promise<boolean>;
  // Codette Transport Control (Phase 3)
  codetteTransportPlay: () => Promise<any>;
  codetteTransportStop: () => Promise<any>;
  codetteTransportSeek: (timeSeconds: number) => Promise<any>;
  codetteSetTempo: (bpm: number) => Promise<any>;
  codetteSetLoop: (
    enabled: boolean,
    startTime?: number,
    endTime?: number
  ) => Promise<any>;
  // WebSocket Status (Phase 4)
  getWebSocketStatus: () => { connected: boolean; reconnectAttempts: number };
  getCodetteBridgeStatus: () => {
    connected: boolean;
    reconnectCount: number;
    isReconnecting: boolean;
  };
  // Clipboard Operations
  clipboardData: { type: 'track' | 'clip' | null; data: any };
  cutTrack: (trackId: string) => void;
  copyTrack: (trackId: string) => void;
  pasteTrack: () => void;
  selectAllTracks: () => void;
  deselectAllTracks: () => void;
  selectedTracks: Set<string>;
  // Utility
  cpuUsageDetailed: Record<string, number>;

  // Recording state (NEW)
  recordingTrackId: null | string;
  recordingStartTime: number;
  recordingTakeCount: number;
  recordingMode: 'audio' | 'midi' | 'overdub';
  punchInEnabled: boolean;
  punchInTime: number;
  punchOutTime: number;
  recordingBlob: Blob | null;
  recordingError: string | null;
  
  // Recording methods (NEW)
  startRecording: (trackId: string) => Promise<boolean>;
  stopRecording: () => Promise<Blob | null>;
  pauseRecording: () => boolean;
  resumeRecording: () => boolean;
  setRecordingMode: (mode: 'audio' | 'midi' | 'overdub') => void;
  setPunchInOut: (punchIn: number, punchOut: number) => void;
  togglePunchIn: () => void;
  undoLastRecording: () => void;

  // Phase 9: Effect Chain Management (from EffectChainContextAPI)
  effectChainsByTrack: EffectChainContextAPI['effectChainsByTrack'];
  getTrackEffects: EffectChainContextAPI['getTrackEffects'];
  addEffectToTrack: EffectChainContextAPI['addEffectToTrack'];
  removeEffectFromTrack: EffectChainContextAPI['removeEffectFromTrack'];
  updateEffectParameter: EffectChainContextAPI['updateEffectParameter'];
  enableDisableEffect: EffectChainContextAPI['enableDisableEffect'];
  setEffectWetDry: EffectChainContextAPI['setEffectWetDry'];
  getEffectChainForTrack: EffectChainContextAPI['getEffectChainForTrack'];
  processTrackEffects: EffectChainContextAPI['processTrackEffects'];
  hasActiveEffects: EffectChainContextAPI['hasActiveEffects'];
}

// DAW Provider component
export const DAWProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  // State and context initialization
  const [currentProject, setCurrentProject] = useState<Project | null>(null);
  const [tracks, setTracks] = useState<Track[]>([]);
  const [selectedTrack, setSelectedTrack] = useState<Track | null>(null);
  const [isPlaying, setIsPlaying] = useState<boolean>(false);
  const [isRecording, setIsRecording] = useState<boolean>(false);
  const [currentTime, setCurrentTime] = useState<number>(0);
  const [zoom, setZoom] = useState<number>(1);
  const [logicCoreMode, setLogicCoreMode] = useState<LogicCoreMode>("normal");
  const [voiceControlActive, setVoiceControlActive] = useState<boolean>(false);
  const [cpuUsage, setCpuUsage] = useState<number>(0);
  const [isUploadingFile, setIsUploadingFile] = useState<boolean>(false);
  const [uploadError, setUploadError] = useState<string | null>(null);
  const [deletedTracks, setDeletedTracks] = useState<Track[]>([]);
  const [canUndo, setCanUndo] = useState<boolean>(false);
  const [canRedo, setCanRedo] = useState<boolean>(false);
  const [markers, setMarkers] = useState<Marker[]>([]);
  const [loopRegion, setLoopRegion] = useState<LoopRegion | null>(null);
  const [metronomeSettings, setMetronomeSettings] = useState<MetronomeSettings>({
    enabled: false,
    volume: 1,
    beatSound: "default",
  });

  // Audio I/O State - Real device management
  const [selectedInputDeviceId, setSelectedInputDeviceId] = useState<string | null>(null);
  const [selectedOutputDeviceId, setSelectedOutputDeviceId] = useState<string | null>(null);
  const [inputLevel, setInputLevel] = useState<number>(0);
  const [latencyMs, setLatencyMs] = useState<number>(0);
  const [bufferUnderruns, setBufferUnderruns] = useState<number>(0);
  const [bufferOverruns, setBufferOverruns] = useState<number>(0);
  const [isAudioIOActive, setIsAudioIOActive] = useState<boolean>(false);
  const [audioIOError, setAudioIOError] = useState<string | null>(null);

  // MIDI State
  const [midiDevices] = useState<MidiDevice[]>([]);
  const [midiRoutes, setMidiRoutes] = useState<MidiRoute[]>([]);
  
  // Phase 9: Effect Chain API
  const effectChainAPI = useEffectChainAPI();
  
  // WebSocket Status (Phase 4)
  const [webSocketStatus, setWebSocketStatus] = useState<{ connected: boolean; reconnectAttempts: number }>({
    connected: false,
    reconnectAttempts: 0,
  });

  const getAudioContextStatus = () => {
    // Implementation for getting the audio context status
    return "running";
  };

  const togglePlay = () => {
    setIsPlaying((prev) => !prev);
  };

  const toggleRecord = () => {
    setIsRecording((prev) => !prev);
  };

  const stop = () => {
    setIsPlaying(false);
    setIsRecording(false);
    setCurrentTime(0);
  };

  const saveProject = async () => {
    if (!currentProject) return;
    setIsUploadingFile(true);
    try {
      await supabase
        .from("projects")
        .insert([{ ...currentProject, id: undefined }])
        .single();
      setCurrentProject(currentProject);
    } catch (error) {
      console.error("Error saving project:", error);
      setUploadError("Error saving project. Please try again.");
    } finally {
      setIsUploadingFile(false);
    }
  };

  const loadProject = async (projectId: string) => {
    setIsUploadingFile(true);
    try {
      const { data, error } = await supabase
        .from("projects")
        .select("*")
        .eq("id", projectId)
        .single();

      if (error) throw error;

      setCurrentProject(data);
    } catch (error) {
      console.error("Error loading project:", error);
      setUploadError("Error loading project. Please try again.");
    } finally {
      setIsUploadingFile(false);
    }
  };

  // Sync DAW state to Codette AI (Phase 1)
  const syncDAWStateToCodette = async () => {
    // Implementation for syncing DAW state to Codette AI
    return true;
  };

  // Codette Transport Control (Phase 3)
  const codetteTransportPlay = async () => {
    // Implementation for Codette transport play
  };

  const codetteTransportStop = async () => {
    // Implementation for Codette transport stop
  };

  const codetteTransportSeek = async (timeSeconds: number) => {
    // Implementation for Codette transport seek
  };

  const codetteSetTempo = async (bpm: number) => {
    // Implementation for setting tempo in Codette
  };

  const codetteSetLoop = async (
    enabled: boolean,
    startTime?: number,
    endTime?: number
  ) => {
    // Implementation for setting loop in Codette
  };

  const cutTrack = (trackId: string) => {
    // Implementation for cutting a track
  };

  const copyTrack = (trackId: string) => {
    // Implementation for copying a track
  };

  const pasteTrack = () => {
    // Implementation for pasting a track
  };

  const selectAllTracks = () => {
    // Implementation for selecting all tracks
  };

  const deselectAllTracks = () => {
    // Implementation for deselecting all tracks
  };

  const startRecording = async (trackId: string) => {
    // Implementation for starting recording
    return true;
  };

  const stopRecording = async () => {
    // Implementation for stopping recording
    return null;
  };

  const pauseRecording = () => {
    // Implementation for pausing recording
    return true;
  };

  const resumeRecording = () => {
    // Implementation for resuming recording
    return true;
  };

  const setRecordingMode = (mode: 'audio' | 'midi' | 'overdub') => {
    // Implementation for setting recording mode
  };

  const setPunchInOut = (punchIn: number, punchOut: number) => {
    // Implementation for setting punch in and out
  };

  const togglePunchIn = () => {
    // Implementation for toggling punch in
  };

  const undoLastRecording = () => {
    console.log("Undo last recording action");
    setRecordingTakeCount((prev: number) => Math.max(0, prev - 1));
  };

  // Phase 9: Effect Chain Management (from EffectChainContextAPI)
  const {
    effectChainsByTrack,
    getTrackEffects,
    addEffectToTrack,
    removeEffectFromTrack,
    updateEffectParameter,
    enableDisableEffect,
    setEffectWetDry,
    getEffectChainForTrack,
    processTrackEffects,
    hasActiveEffects,
  } = effectChainAPI;

  // Context value
  const contextValue = {
    currentProject,
    tracks,
    selectedTrack,
    isPlaying,
    isRecording,
    currentTime,
    zoom,
    logicCoreMode,
    voiceControlActive,
    cpuUsage,
    isUploadingFile,
    uploadError,
    deletedTracks,
    canUndo,
    canRedo,
    markers,
    loopRegion,
    metronomeSettings,
    inputLevel,
    latencyMs,
    bufferUnderruns,
    bufferOverruns,
    isAudioIOActive,
    audioIOError,
    selectedInputDevice: null,
    selectedInputDeviceId,
    selectedOutputDeviceId,
    selectInputDevice: async () => {},
    selectOutputDevice: async () => {},
    getAudioContextStatus,
    setCurrentProject,
    addTrack: async () => {},
    selectTrack: setSelectedTrack,
    updateTrack: async () => {},
    deleteTrack: async () => {},
    duplicateTrack: async () => null,
    restoreTrack: async () => {},
    permanentlyDeleteTrack: async () => {},
    togglePlay,
    toggleRecord,
    stop,
    setLogicCoreMode,
    toggleVoiceControl,
    saveProject,
    loadProject,
    uploadAudioFile: async () => false,
    getWaveformData: () => [],
    getAudioDuration: () => 0,
    getAudioBufferData: () => null,
    getAudioLevels: () => null,
    seek: () => {},
    setTrackInputGain: () => {},
    addPluginToTrack: () => {},
    removePluginFromTrack: () => {},
    togglePluginEnabled: () => {},
    undo,
    redo,
    // Phase 3: Markers
    addMarker: () => {},
    deleteMarker: () => {},
    updateMarker: () => {},
    // Phase 3: Looping
    setLoopRegion: () => {},
    toggleLoop: () => {},
    clearLoopRegion: () => {},
    // Phase 3: Metronome
    toggleMetronome: () => {},
    setMetronomeVolume: () => {},
    setMetronomeBeatSound: () => {},
    // Modal State
    showNewProjectModal: false,
    openNewProjectModal: () => {},
    closeNewProjectModal: () => {},
    showExportModal: false,
    openExportModal: () => {},
    closeExportModal: () => {},
    showAudioSettingsModal: false,
    openAudioSettingsModal: () => {},
    closeAudioSettingsModal: () => {},
    showAboutModal: false,
    openAboutModal: () => {},
    closeAboutModal: () => {},
    // Additional Modals
    showSaveAsModal: false,
    openSaveAsModal: () => {},
    closeSaveAsModal: () => {},
    showOpenProjectModal: false,
    openOpenProjectModal: () => {},
    closeOpenProjectModal: () => {},
    showMidiSettingsModal: false,
    openMidiSettingsModal: () => {},
    closeMidiSettingsModal: () => {},
    showMixerOptionsModal: false,
    openMixerOptionsModal: () => {},
    closeMixerOptionsModal: () => {},
    showPreferencesModal: false,
    openPreferencesModal: () => {},
    closePreferencesModal: () => {},
    showShortcutsModal: false,
    openShortcutsModal: () => {},
    closeShortcutsModal: () => {},
    // Export
    exportAudio: async () => {},
    // Project Import/Export
    exportProjectAsFile: () => {},
    importProjectFromFile: async () => {},
    // Bus/Routing functions
    buses: [],
    createBus: async () => {},
    deleteBus: async () => {},
    addTrackToBus: async () => {},
    removeTrackFromBus: async () => {},
    createSidechain: async () => {},
    // Plugin functions
    loadPlugin: () => {},
    unloadPlugin: () => {},
    loadedPlugins: new Map<string, Plugin[]>(),
    // MIDI functions
    midiDevices,
    createMIDIRoute: async () => {},
    deleteMIDIRoute: async () => {},
    getMIDIRoutesForTrack: () => [],
    // Codette AI Integration (Phase 1)
    codetteConnected: false,
    codetteLoading: false,
    codetteSuggestions: [] as CodetteSuggestion[],
    getSuggestionsForTrack: async () => [],
    applyCodetteSuggestion: async () => false,
    analyzeTrackWithCodette: async () => ({}),
    syncDAWStateToCodette,
    // Codette Transport Control (Phase 3)
    codetteTransportPlay,
    codetteTransportStop,
    codetteTransportSeek,
    codetteSetTempo,
    codetteSetLoop,
    // WebSocket Status (Phase 4)
    getWebSocketStatus: () => webSocketStatus,
    getCodetteBridgeStatus: () => ({
      connected: false,
      reconnectCount: 0,
      isReconnecting: false,
    }),
    // Clipboard Operations
    clipboardData: { type: 'track' | 'clip' | null, data: null },
    cutTrack,
    copyTrack,
    pasteTrack,
    selectAllTracks,
    deselectAllTracks,
    selectedTracks: new Set<string>(),
    // Utility
    cpuUsageDetailed: {},

    // Recording state (NEW)
    recordingTrackId: null,
    recordingStartTime: 0,
    recordingTakeCount: 0,
    recordingMode: 'audio',
    punchInEnabled: false,
    punchInTime: 0,
    punchOutTime: 0,
    recordingBlob: null,
    recordingError: null,
    
    // Recording methods (NEW)
    startRecording,
    stopRecording,
    pauseRecording,
    resumeRecording,
    setRecordingMode,
    setPunchInOut,
    togglePunchIn,
    undoLastRecording,

    // Phase 9: Effect Chain Management (from EffectChainContextAPI)
    ...effectChainAPI,
  };

  return (
    <DAWContext.Provider value={contextValue}>
      {children}
    </DAWContext.Provider>
  );
};

export const useDAWContext = () => {
  return useContext(DAWContext);
};

// Export as useDAW for easier usage
export const useDAW = useDAWContext;

const DAWContext = createContext<DAWContextType | undefined>(undefined);
