/**
 * MIDI Utilities
 * Functions for note conversion, quantization, humanization, and playback
 */

import { MIDINote, MIDISequence, MIDI_NOTES, MIDI_RANGE } from '../types/midi';

/**
 * Convert MIDI pitch number to note name
 * @param pitch MIDI pitch (0-127)
 * @returns Note name (e.g., "C4", "A#5")
 */
export const pitchToNote = (pitch: number): string => {
  if (pitch < MIDI_RANGE.MIN || pitch > MIDI_RANGE.MAX) {
    return 'Invalid';
  }

  const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
  const octave = Math.floor(pitch / 12) - 1;
  const note = notes[pitch % 12];

  return `${note}${octave}`;
};

/**
 * Convert note name to MIDI pitch
 * @param note Note name (e.g., "C4", "A#5")
 * @returns MIDI pitch (0-127)
 */
export const noteToP itch = (note: string): number => {
  const match = note.match(/([A-G]#?)(-?\d+)/);
  if (!match) return -1;

  const [, noteName, octaveStr] = match;
  const octave = parseInt(octaveStr);
  const noteIndex = MIDI_NOTES[noteName as keyof typeof MIDI_NOTES];

  if (noteIndex === undefined) return -1;

  const pitch = (octave + 1) * 12 + noteIndex;
  return Math.max(MIDI_RANGE.MIN, Math.min(MIDI_RANGE.MAX, pitch));
};

/**
 * Convert MIDI pitch to frequency in Hz
 * Uses A4 = 440 Hz standard tuning
 * @param pitch MIDI pitch (0-127)
 * @returns Frequency in Hz
 */
export const pitchToFrequency = (pitch: number): number => {
  const A4 = 440;
  const A4_MIDI = 69;
  return A4 * Math.pow(2, (pitch - A4_MIDI) / 12);
};

/**
 * Convert frequency to MIDI pitch
 * @param frequency Frequency in Hz
 * @returns MIDI pitch (0-127)
 */
export const frequencyToPitch = (frequency: number): number => {
  const A4 = 440;
  const A4_MIDI = 69;
  return Math.round(12 * Math.log2(frequency / A4) + A4_MIDI);
};

/**
 * Convert time to beats based on BPM
 * @param time Time in seconds
 * @param bpm Beats per minute
 * @returns Number of beats
 */
export const timeToBeats = (time: number, bpm: number): number => {
  return (time / 60) * bpm;
};

/**
 * Convert beats to time based on BPM
 * @param beats Number of beats
 * @param bpm Beats per minute
 * @returns Time in seconds
 */
export const beatsToTime = (beats: number, bpm: number): number => {
  return (beats * 60) / bpm;
};

/**
 * Get grid position in seconds for a given quantize value
 * @param time Time in seconds
 * @param quantizeValue Grid division (4=quarter, 8=eighth, 16=sixteenth)
 * @param bpm Beats per minute
 * @returns Quantized time in seconds
 */
export const getGridPosition = (
  time: number,
  quantizeValue: number,
  bpm: number
): number => {
  const beatDuration = beatsToTime(1, bpm);
  const gridSize = beatDuration / quantizeValue;
  return Math.round(time / gridSize) * gridSize;
};

/**
 * Quantize a single note to grid
 * @param note MIDI note to quantize
 * @param quantizeValue Grid division (4=quarter, 8=eighth, 16=sixteenth)
 * @param bpm Beats per minute
 * @returns Quantized note
 */
export const quantizeNote = (
  note: MIDINote,
  quantizeValue: number,
  bpm: number
): MIDINote => {
  const beatDuration = beatsToTime(1, bpm);
  const gridSize = beatDuration / quantizeValue;

  const quantizedStart = Math.round(note.startTime / gridSize) * gridSize;
  const quantizedDuration = Math.round(note.duration / gridSize) * gridSize;

  return {
    ...note,
    startTime: Math.max(0, quantizedStart),
    duration: Math.max(gridSize, quantizedDuration),
  };
};

/**
 * Quantize all notes in a sequence
 * @param notes Array of MIDI notes
 * @param quantizeValue Grid division (4=quarter, 8=eighth, 16=sixteenth)
 * @param bpm Beats per minute
 * @returns Array of quantized notes
 */
export const quantizeNotes = (
  notes: MIDINote[],
  quantizeValue: number,
  bpm: number
): MIDINote[] => {
  return notes.map(note => quantizeNote(note, quantizeValue, bpm));
};

/**
 * Humanize notes with random timing and velocity variation
 * @param notes Array of MIDI notes
 * @param amount Humanization amount (0-0.1 typical)
 * @returns Array of humanized notes
 */
export const humanizeNotes = (notes: MIDINote[], amount: number): MIDINote[] => {
  return notes.map(note => ({
    ...note,
    startTime: Math.max(0, note.startTime + (Math.random() - 0.5) * amount),
    velocity: Math.max(1, Math.min(127, note.velocity + (Math.random() - 0.5) * 10)),
  }));
};

/**
 * Create a new empty MIDI sequence
 * @param bpm Beats per minute (default 120)
 * @param length Sequence length in seconds (default 16 seconds = 4 bars at 120 BPM)
 * @returns New MIDI sequence
 */
export const createEmptySequence = (bpm: number = 120, length: number = 16): MIDISequence => {
  return {
    id: `seq-${Date.now()}`,
    name: 'Untitled',
    notes: [],
    bpm,
    timeSignature: [4, 4],
    length,
    loop: true,
  };
};

/**
 * Calculate sequence length based on BPM and beats
 * @param beats Number of beats
 * @param bpm Beats per minute
 * @returns Length in seconds
 */
export const calculateSequenceLength = (beats: number, bpm: number): number => {
  return beatsToTime(beats, bpm);
};

/**
 * Get all notes that overlap with a time range
 * @param notes Array of MIDI notes
 * @param startTime Start of time range
 * @param endTime End of time range
 * @returns Notes that overlap with time range
 */
export const getNotesInTimeRange = (
  notes: MIDINote[],
  startTime: number,
  endTime: number
): MIDINote[] => {
  return notes.filter(note => {
    const noteEnd = note.startTime + note.duration;
    return note.startTime < endTime && noteEnd > startTime;
  });
};

/**
 * Get all notes at a specific pitch
 * @param notes Array of MIDI notes
 * @param pitch MIDI pitch
 * @returns Notes at that pitch
 */
export const getNotesAtPitch = (notes: MIDINote[], pitch: number): MIDINote[] => {
  return notes.filter(note => note.pitch === pitch);
};

/**
 * Move notes by a time offset
 * @param notes Array of MIDI notes
 * @param offset Time offset in seconds
 * @returns Moved notes
 */
export const moveNotes = (notes: MIDINote[], offset: number): MIDINote[] => {
  return notes.map(note => ({
    ...note,
    startTime: Math.max(0, note.startTime + offset),
  }));
};

/**
 * Transpose notes by semitones
 * @param notes Array of MIDI notes
 * @param semitones Number of semitones to transpose (+/-)
 * @returns Transposed notes
 */
export const transposeNotes = (notes: MIDINote[], semitones: number): MIDINote[] => {
  return notes.map(note => ({
    ...note,
    pitch: Math.max(MIDI_RANGE.MIN, Math.min(MIDI_RANGE.MAX, note.pitch + semitones)),
  }));
};

/**
 * Scale note velocities
 * @param notes Array of MIDI notes
 * @param scale Scale factor (1.0 = no change, 0.5 = half, 2.0 = double)
 * @returns Notes with scaled velocities
 */
export const scaleVelocities = (notes: MIDINote[], scale: number): MIDINote[] => {
  return notes.map(note => ({
    ...note,
    velocity: Math.max(1, Math.min(127, Math.round(note.velocity * scale))),
  }));
};

/**
 * Validate a MIDI sequence
 * @param sequence MIDI sequence to validate
 * @returns Array of error messages (empty if valid)
 */
export const validateSequence = (sequence: MIDISequence): string[] => {
  const errors: string[] = [];

  if (!sequence.id) errors.push('Sequence must have an ID');
  if (!sequence.name) errors.push('Sequence must have a name');
  if (sequence.bpm < 1 || sequence.bpm > 300) errors.push('BPM must be between 1 and 300');
  if (sequence.length <= 0) errors.push('Sequence length must be positive');

  sequence.notes.forEach((note, idx) => {
    if (note.pitch < MIDI_RANGE.MIN || note.pitch > MIDI_RANGE.MAX) {
      errors.push(`Note ${idx} pitch out of range`);
    }
    if (note.velocity < 0 || note.velocity > 127) {
      errors.push(`Note ${idx} velocity out of range`);
    }
    if (note.duration <= 0) {
      errors.push(`Note ${idx} duration must be positive`);
    }
    if (note.startTime < 0) {
      errors.push(`Note ${idx} start time cannot be negative`);
    }
    if (note.startTime + note.duration > sequence.length) {
      errors.push(`Note ${idx} extends beyond sequence length`);
    }
  });

  return errors;
};
